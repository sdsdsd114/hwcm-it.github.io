# P2240 【深基12.例1】部分背包问题

## 题目描述

阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\le m_i,v_i \le 100)$。阿里巴巴有一个承重量为 $T(T \le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？

## 输入格式

第一行两个整数 $N,T$。

接下来 $N$ 行，每行两个整数 $m_i,v_i$。

## 输出格式

一个实数表示答案，输出两位小数

## 输入输出样例 #1

### 输入 #1

```
4 50
10 60
20 100
30 120
15 45
```

### 输出 #1

```
240.00
```
# 贪心算法解决部分背包问题
以下是用C语言实现的部分背包问题代码，核心思路是按单位价值排序后贪心选择：

```c
#include<stdio.h>
#include<stdlib.h>

typedef struct {
    int weight;
    int value;
    double unit_value;
} Gold;

int compare(const void* a, const void* b) {
    Gold* goldA = (Gold*)a;
    Gold* goldB = (Gold*)b;
    if (goldA->unit_value > goldB->unit_value) return -1;
    if (goldA->unit_value < goldB->unit_value) return 1;
    return 0;
}

int main(){
    int N, T;
    scanf("%d%d", &N, &T);
    Gold golds[100];
    for(int i=0; i<N; i++){
        scanf("%d%d", &golds[i].weight, &golds[i].value);
        golds[i].unit_value = (double)golds[i].value / golds[i].weight; 
    }
    qsort(golds, N, sizeof(Gold), compare);
    double total_value = 0.0;
    int remaining = T;
    for(int i=0; i<N; i++){
        if(remaining >= golds[i].weight){
            total_value += golds[i].value;
            remaining -= golds[i].weight;
        } else {
            total_value += golds[i].unit_value * remaining;
            break;
        }
    }
    printf("%.2f\n", total_value);
    return 0;
}